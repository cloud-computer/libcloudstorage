#include "FuseCommon.h"

#include "ICloudStorage.h"
#include "Utility/HttpServer.h"
#include "Utility/Utility.h"

#include "FuseDokan.h"
#include "FuseHighLevel.h"
#include "FuseLowLevel.h"
#include "FuseWinFsp.h"

#include <codecvt>
#include <cstring>
#include <fstream>
#include <sstream>

namespace cloudstorage {

namespace {

#define OPTION(t, p) \
  { t, offsetof(struct options, p), 1 }

template <class T>
using pointer = std::unique_ptr<T, std::function<void(T *)>>;

struct options {
  ~options() {
    free(config_file);
    free(add_provider_label);
    free(remove_provider_label);
  }
  char *config_file;
  char *add_provider_label;
  char *remove_provider_label;
  int list_providers;
};

const struct fuse_opt option_spec[] = {
    OPTION("--config=%s", config_file), OPTION("--add=%s", add_provider_label),
    OPTION("--remove=%s", remove_provider_label),
    OPTION("--list", list_providers), FUSE_OPT_END};
}  // namespace

std::string to_string(const std::wstring &str) {
  return std::wstring_convert<std::codecvt_utf8<wchar_t>>().to_bytes(str);
}

std::wstring from_string(const std::string &str) {
  return std::wstring_convert<std::codecvt_utf8<wchar_t>>().from_bytes(str);
}

struct FUSE_STAT item_to_stat(const IFileSystem::INode::Pointer &i) {
  struct FUSE_STAT ret = {};
#ifndef _WIN32
  if (i->timestamp() != IItem::UnknownTimeStamp)
    ret.st_mtime = std::chrono::system_clock::to_time_t(i->timestamp());
#endif
  if (i->size() != IItem::UnknownSize)
    ret.st_size = i->size();
  else if (i->type() != IItem::FileType::Directory)
    ret.st_size = 1LL << 32;
  ret.st_mode =
      (i->type() == IItem::FileType::Directory ? S_IFDIR : S_IFREG) | 0744;
  ret.st_ino = i->inode();
  return ret;
}

IHttpRequest::Pointer HttpWrapper::create(const std::string &url,
                                          const std::string &method,
                                          bool follow_redirect) const {
  return http_->create(url, method, follow_redirect);
}

void ThreadPoolWrapper::schedule(
    const Task &f, const std::chrono::system_clock::time_point &when) {
  thread_pool_->schedule(f, when);
}

IHttpServer::IResponse::Pointer HttpServerCallback::handle(
    const IHttpServer::IRequest &request) {
  auto code = request.get("code");
  auto state = request.get("state");
  if (code && state) {
    promise_.set_value({code, state});
    return util::response_from_string(request, IHttpRequest::Ok, {},
                                      "token received");
  } else if (request.url() == "/login" && state) {
    return util::response_from_string(request, IHttpRequest::Ok, {},
                                      util::login_page(state));
  } else {
    return util::response_from_string(request, IHttpRequest::Bad, {}, "error");
  }
}

ICloudProvider::Pointer create(
    int index, std::shared_ptr<IHttpServerFactory> http_server_factory,
    std::shared_ptr<IHttp> http, std::shared_ptr<IThreadPool> thread_pool,
    std::string temporary_directory, Json::Value config) {
  class ServerFactoryWrapper : public IHttpServerFactory {
   public:
    ServerFactoryWrapper(std::shared_ptr<IHttpServerFactory> f)
        : factory_(std::move(f)) {}
    IHttpServer::Pointer create(IHttpServer::ICallback::Pointer cb,
                                const std::string &ssid,
                                IHttpServer::Type type) override {
      return factory_->create(cb, ssid, type);
    }

   private:
    std::shared_ptr<IHttpServerFactory> factory_;
  };
  class AuthCallback : public ICloudProvider::IAuthCallback {
    Status userConsentRequired(const ICloudProvider &) override {
      return Status::None;
    }
    void done(const ICloudProvider &, EitherError<void>) override {}
  };
  ICloudProvider::InitData init_data;
  init_data.permission_ = ICloudProvider::Permission::ReadWrite;
  init_data.callback_ = util::make_unique<AuthCallback>();
  init_data.token_ = config["token"].asString();
  init_data.http_engine_ = util::make_unique<HttpWrapper>(http);
  init_data.http_server_ =
      util::make_unique<ServerFactoryWrapper>(http_server_factory);
  init_data.thread_pool_ = util::make_unique<ThreadPoolWrapper>(thread_pool);
  init_data.hints_["file_url"] =
      "http://127.0.0.1:12345/" + std::to_string(index);
  init_data.hints_["state"] = std::to_string(index);
  init_data.hints_["access_token"] = config["access_token"].asString();
  init_data.hints_["temporary_directory"] = std::move(temporary_directory);
  return ICloudStorage::create()->provider(config["type"].asString(),
                                           std::move(init_data));
}

std::vector<IFileSystem::ProviderEntry> providers(
    const Json::Value &data,
    const std::shared_ptr<IHttpServerFactory> &http_server_factory,
    const std::shared_ptr<IHttp> &http,
    const std::shared_ptr<IThreadPool> &thread_pool,
    const std::string &temporary_directory) {
  std::vector<IFileSystem::ProviderEntry> providers;
  int index = 0;
  for (auto &&p : data)
    providers.push_back(
        {p["label"].asString(), create(index++, http_server_factory, http,
                                       thread_pool, temporary_directory, p)});
  return providers;
}

template <class Backend>
int fuse_run(fuse_args *args, fuse_cmdline_opts *opts, Json::Value &json) {
  if (!opts->mountpoint) {
    std::cerr << "missing mountpoint\n";
    return 1;
  }
  auto ctx = new IFileSystem *;
  Backend fuse(args, opts->mountpoint, ctx);
  fuse_daemonize(opts->foreground);
  std::shared_ptr<IHttp> http = IHttp::create();
  std::shared_ptr<IThreadPool> thread_pool = IThreadPool::create(1);
  std::shared_ptr<IHttpServerFactory> http_server_factory =
      util::make_unique<ServerWrapperFactory>(
          IHttpServerFactory::create().get());
  auto temporary_directory = json["temporary_directory"].asString();
  if (temporary_directory.empty())
    temporary_directory = util::temporary_directory();
  auto p = providers(json["providers"], http_server_factory, http, thread_pool,
                     temporary_directory);
  *ctx = IFileSystem::create(p, util::make_unique<HttpWrapper>(http),
                             temporary_directory)
             .release();
  int ret = fuse.run(opts->singlethread, opts->clone_fd);
  for (size_t i = 0; i < p.size(); i++) {
    json["providers"][int(i)]["token"] = p[i].provider_->token();
    json["providers"][int(i)]["access_token"] =
        p[i].provider_->hints()["access_token"];
  }
  delete *ctx;
  delete ctx;
  return ret;
}

int fuse_run(int argc, char **argv) {
  pointer<fuse_args> args(new fuse_args(FUSE_ARGS_INIT(argc, argv)),
                          [](fuse_args *e) {
                            fuse_opt_free_args(e);
                            delete e;
                          });
  struct options options {};
  if (fuse_opt_parse(args.get(), &options, option_spec, nullptr) == -1)
    return 1;
  if (!options.config_file)
    options.config_file = strdup(
        (cloudstorage::util::home_directory() + "/.libcloudstorage-fuse.json")
            .c_str());
  pointer<fuse_cmdline_opts> opts(new fuse_cmdline_opts{},
                                  [](fuse_cmdline_opts *opts) {
                                    free(opts->mountpoint);
                                    delete opts;
                                  });
  if (fuse_parse_cmdline(args.get(), opts.get()) != 0) return 1;
  if (opts->show_help) {
    std::cerr << util::libcloudstorage_ascii_art() << "\n\n";
    std::cerr << "    --add=label            add cloud provider with label\n";
    std::cerr << "    --remove=label         remove cloud provider\n";
    std::cerr << "    --list                 list cloud providers\n";
    std::cerr << "    --config=config_path   path to configuration file\n";
    std::cerr << "                           (default: "
                 "~/.libcloudstorage-fuse.json)\n";
    std::cerr << "\n";
    fuse_cmdline_help();
#ifdef WITH_FUSE
    fuse_lowlevel_help();
#endif
    return 0;
  } else if (opts->show_version) {
#ifdef WITH_FUSE
    fuse_lowlevel_version();
#endif
    return 0;
  }
  Json::Value json;
  try {
    json = cloudstorage::util::json::from_stream(
        std::ifstream(options.config_file));
  } catch (const Json::Exception &) {
  }
  if (options.add_provider_label) {
    for (auto p : json["providers"])
      if (p["label"].asString() == options.add_provider_label) {
        std::cerr << "Provider with label " << options.add_provider_label
                  << " already exists.\n";
        return 1;
      }
    std::cerr << cloudstorage::util::libcloudstorage_ascii_art() << "\n";
    auto storage = ICloudStorage::create();
    for (auto &&p : storage->providers()) {
      ICloudProvider::InitData init_data;
      init_data.hints_["state"] = p;
      init_data.permission_ = ICloudProvider::Permission::ReadWrite;
      std::cerr << "\n";
      std::cerr
          << p << ": "
          << storage->provider(p, std::move(init_data))->authorizeLibraryUrl()
          << "\n";
    }
    std::promise<cloudstorage::HttpServerData> result;
    auto server = cloudstorage::IHttpServerFactory::create()->create(
        std::make_shared<cloudstorage::HttpServerCallback>(result), "",
        IHttpServer::Type::Authorization);
    if (!server) {
      std::cerr << "Couldn't initialize http server.\n";
      return 1;
    }
    auto key = result.get_future().get();
    ICloudProvider::InitData data;
    data.permission_ = ICloudProvider::Permission::ReadWrite;
    auto provider = storage->provider(key.state_, std::move(data));
    if (!provider) return 1;
    auto ret = provider->exchangeCodeAsync(key.code_)->result();
    if (auto token = ret.right()) {
      Json::Value p;
      p["label"] = options.add_provider_label;
      p["type"] = provider->name();
      p["token"] = token->token_;
      p["access_token"] = token->access_token_;
      json["providers"].append(p);
      std::ofstream(options.config_file) << json;
    } else
      std::cerr << "error " << ret.left()->code_ << ": "
                << ret.left()->description_ << "\n";
    return 0;
  } else if (options.remove_provider_label) {
    Json::Value providers(Json::arrayValue);
    bool removed = false;
    for (auto p : json["providers"])
      if (p["label"].asString() != options.remove_provider_label)
        providers.append(p);
      else {
        removed = true;
      }
    if (removed) {
      json["providers"] = providers;
      std::ofstream(options.config_file) << json;
    } else {
      std::cerr << "Failed to remove " << options.remove_provider_label << "\n";
      return 1;
    }
    return 0;
  } else if (options.list_providers) {
    std::cout << std::setw(20) << std::left << "TYPE"
              << "LABEL\n";
    for (auto p : json["providers"])
      std::cout << std::setw(20) << std::left << p["type"].asString()
                << p["label"].asString() << "\n";
    return 0;
  }
  int ret = 0;

#ifdef WITH_WINFSP
  ret = fuse_run<FuseWinFsp>(args.get(), opts.get(), json);
#elif WITH_DOKAN
  ret = fuse_run<FuseDokan>(args.get(), opts.get(), json);
#else
#ifdef FUSE_LOWLEVEL
  ret = fuse_run<FuseLowLevel>(args.get(), opts.get(), json);
#else
  ret = fuse_run<FuseHighLevel>(args.get(), opts.get(), json);
#endif
#endif

  std::ofstream(options.config_file) << json;
  return ret;
}

}  // namespace cloudstorage
